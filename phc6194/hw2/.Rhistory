axis(side=1, at=1:nrow(x), labels=x$names, las = 3,
cex.axis = 0.4)
abline(h=0.5, col=adjustcolor("darkred", alpha.f=.6), lwd =2)
# ###########
# # ASSIGN TO TREATMENT GROUPS # OPTION 2
# ###########
# #instead of sampling across the whole population, this option
# # insures that for each strata, the number of individuals assigned to treatment
# # is identical to those assigned to control (or only off by one, if odd number)
#
# # FIRST, RANDOMIZE ORDER OF ROWS IN postRobo
# set.seed(1)
#
# # Write function for randomizing row order
# RandomRows = function(df){
#   return(df[sample(nrow(df),nrow(df)),])
# }
#
# # Randomize row order
# postRobo <- RandomRows(df = postRobo)
#
# # create empty vector for assignment
# postRobo$assignment <- NA
#
# # assign treatment to the first half of each strata, control to the second half
# # doing this by halves works since the order is random
# for (i in unique(postRobo$strat)){
#
#   myStrat <- postRobo[which(postRobo$strat == i),]
#
#   myHalf <- round(nrow(myStrat)/2)
#
#   myStrat$myAssig <- NA
#   myStrat$myAssig[1:myHalf] <- "treatment"
#   #myStrat$myAssig[(myHalf+1):nrow(myStrat)] <- "control"
#   myStrat$myAssig[which(is.na(myStrat$myAssig))] <- "control"
#
#
#   postRobo$assignment[which(postRobo$strat == i)] <-
#     myStrat$myAssig
# }
#
# # Have a look at the balances
# for (i in 1:length(levels(factor(postRobo$strat)))){
#   print(paste(levels(factor(postRobo$strat))[i],
#               summary(factor(postRobo$assignment[which(as.numeric(factor(postRobo$strat)) == i)]))))
# }
#
# ###########
# # Visualize the balance among strata
# ###########
# x <- vector(length = length(levels(factor(postRobo$strat))), mode = "numeric")
# xnames <- vector(length = length(levels(factor(postRobo$strat))), mode = "character")
#
# for (i in 1:length(x)){
#   #what portion get treatment
#   x[i] <- as.numeric(prop.table(table(factor(
#     postRobo$assignment[which(as.numeric(factor(postRobo$strat)) == i)]))))[2]
#   #what strata are we talking about
#   xnames[i] <- levels(factor(postRobo$strat))[i]
# }
#
# # Order x and xnames by x
# x <- data.frame(x)
# x$names <- xnames
# x <- x[order(x$x),]
#
# plot(x$x, xaxt="n", xlab=NA, ylab = "P", main = "Proportion assigned to treatment by strata",
#      pch=16, col=adjustcolor("darkblue", alpha.f=0.6))
# axis(side=1, at=1:nrow(x), labels=x$names, las = 3,
#      cex.axis = 0.4)
# abline(h=0.5, col=adjustcolor("darkred", alpha.f=.6), lwd =2)
###########
# HAVING MADE ASSIGNMENT COLUMN, SUBSET INTO TREATMENT AND CONTROL
###########
treatment <- postRobo[which(postRobo$assignment == "treatment"),]
control <- postRobo[which(postRobo$assignment == "control"),]
###########
# HAVING MADE ASSIGNMENTS, DO SOME SANITY CHECKS
###########
# LIKELIHOOD OF ASSIGNMENT BALANCED ACROSSES
fit <- glm(factor(assignment) ~ strat,
data = postRobo,
family = binomial("logit"))
summary(fit) # p values all look good
# NAMES OF TREATMENT AND CONTROL ARE GOOD
# treatment
hist(nchar(as.character(treatment$LastName)))
nrow(treatment[which(nchar(as.character(treatment$LastName)) == 1),])
#control
hist(nchar(as.character(control$LastName)))
nrow(control[which(nchar(as.character(control$LastName)) == 1),])
# THEY ALL INDEED HAD GOOD PHONE NUMBERS
summary(treatment$goodPhone)
summary(control$goodPhone)
# NOTHING FUNKY ABOUT THEIR AGES
t.test(treatment$Age, control$Age) # p-value looks good
##############
# SUBSET TREATMENT AND CONTROL TO INCLUDE ONLY VARIABLES SPECIFIED BY WILL
##############
treatment <- treatment[,c("VANID", "State", "ad", "FirstName", "LastName", "assignment")]
control <- control[,c("VANID", "State", "ad", "FirstName", "LastName", "assignment")]
##############
# WRITE FINAL MAIL FILES
##############
# write.csv(treatment, "postroboscreen/treatment.csv". row.names = FALSE)
# write.csv(control, "postroboscreen/control.csv", row.names = FALSE)
#########
# END WRITING SINK
#########
txtStop()
# END HERE
# !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
# !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
# !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
# !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
# !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
# !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
#########
system.time(for (i in 1:1000000)){
i^2
}
system.time(for (i in 1:1000000)){
i^2
}
system.time(for (i in 1:1000000)){
i^2
})
system.time(
for (i in 1:1000000){
i^2
})
system.time(
for (i in 1:10000000){
i^2
})
system.time(
for (i in 1:10000000){
i^3
})
#!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
# THIS SCRIPT RANDOMIZES THE UH LOCAL 25 DATA, IN ACCORDANCE WITH WILL'S
# INSTRUCTIONS ON 2014-09-11.  IT IS AN IMPROVEMENT ON uh1.R AND uh2.R
set.seed(1)
#########
# ATTACH PACKAGES
#########
library(RColorBrewer)
library(classInt)
library(TeachingDemos) # for easy sink()ing
library(Hmisc)
library(plyr)
#########
# SET LOCAL WORKING DIRECTORY
#########
setwd('C:/Users/BrewJR/Documents/analystinstitute/unitehere/preroboscreen')
#setwd("/home/joebrew/Documents/analystinstitute/unitehere/preroboscreen")
#########
# BEGIN WRITING SINK
#########
txtStart("uh_pre_robo_log.txt")
#########
# SET SEED
#########
set.seed(1)
#########
# READ IN DATA, NAMING IT UH (unite here)
#########
uh <- read.csv("uh_with_party.txt", sep = "\t")
#########
# MAKE AN ADDRESS COLUMN
#########
# FUNCTION FOR REMOVING TRAILING / LEADING WHITE SPACES
RemoveTrail <- function(var){
x <- gsub("^\\s+|\\s+$", "", var)
return(x)
}
# CREATE AN ad COLUMN (first defining function, then assigning variable)
MakeAdd <- function(data = uh){
# PASTE TOGETHER ADDRESS COMPONENTS
x <- paste0(RemoveTrail(data$mAddress), ", ", #used mailing address, but should I use voting?
RemoveTrail(data$City), ", ",
RemoveTrail(data$State), " ",
RemoveTrail(data$Zip5))
return(x)
}
uh$ad <- MakeAdd(data = uh)
# CHECK LENGTH OF ADDRESSES (IN CHARACTERS) FOR ANY ODDITIES
table(factor(nchar(as.character(uh$ad))))
barplot(summary(factor(nchar(as.character(uh$ad)))))
# a bit concerned about some of those shorter addresses, so...
# REMOVE THOSE WITH FEWER THAN 31 CHARACTERS
# (any more and you start getting PO BOXES, ETC)
uh <- uh[which(nchar(as.character(uh$ad)) > 30),] #drops 895 bad addresses
# RECHECK LENGTH OF ADDRESSES (IN CHARACTERS) FOR ANY ODDITIES
table(factor(nchar(as.character(uh$ad))))
barplot(summary(factor(nchar(as.character(uh$ad)))))
# CHECK ON LONG ADDRESSES (JUST TO MAKE SURE NOTHING'S WONKY)
sample(uh$ad[which(nchar(as.character(uh$ad)) > 62)], 100) # they're fine
#########
# MAKE A VOTE HISTORY COLUMN PER SAUL'S SPECIFICATIONS
#########
# WRITE FUNCTION IN ORDER TO ESTABLISH WHETHER VOTED OR NOT IN A PARTICULAR COLUMN
VoteFun <- function(var, data = uh){
ifelse( nchar(as.character(data[,var])) > 0 & data[,var] != " ",
TRUE,
FALSE)
}
# BOOLEAN FOR WHETHER PERSON EVER VOTED IN 06, 10, OR 12
uh$voter <- ifelse(!VoteFun("General06") &
!VoteFun("General10") &
!VoteFun("General12") &
!VoteFun("Primary06") &
!VoteFun("Primary10") &
!VoteFun("Primary12") &
!VoteFun("Special12"),
FALSE,
TRUE)
# WHAT DOES VOTING HISTORY LOOK LIKE?
table(factor(uh$voter))
prop.table(table(factor(uh$voter)))
# 93.37% meet Saul's "voter" conditions
#########
# LIST OF VARIABLES FOR SAUL
#########
names(uh)
# 43 variables including the concocted "ad" (address) and "voter"
#########
# ONLY KEEP REGISTERED DEMS AND THOSE WITH NO PARTY
#########
table(grepl("D|N", uh$Party))
prop.table(table(grepl("D|N", uh$Party))) # 94.36% are dems or no party
#drop the other 5.6%
dems <- uh[which(grepl("D|N", uh$Party)),]
#########
# DROP ANYONE WHO DIDN'T VOTE IN 2006, 2010, OR 2012
#########
demVoters <- dems[which(dems$voter),] # this drops 14,637
rm(dems) # just to clean up workspace a bit
#########
# DROP THOSE WITH A MAILING ADDRESS OUTSIDE OF DC (WB, 2014-09-09 afternoon)
#########
# How many are there?
nrow(demVoters[which(demVoters$mState != "DC"),]) #3376
# Drop 'em
demVoters <- demVoters[which(demVoters$mState == "DC" ),]
#########
#Check for ID duplicates
#########
length(uh$VANID) != unique(length(uh$VANID)) #none
#########
#DROP PEOPLE WITH MISSING LAST NAMES, FIRST NAMES, MAIL ADDRESS, VOTER ADDRESS,
#AND PHONE
#########
# FIRST, DEFINE FUNCTION FOR MISSING
Missing <- function(var, df = demVoters){
nchar(as.character(df[,var])) == 0
}
# NOW DROP
demVoters <- demVoters[which(!Missing("LastName")),]
demVoters <- demVoters[which(!Missing("FirstName")),]
demVoters <- demVoters[which(!Missing("mAddress")),]
demVoters <- demVoters[which(!Missing("vAddress")),]
demVoters <- demVoters[which(!Missing("Zip5")),]
demVoters <- demVoters[which(!Missing("City")),]
demVoters <- demVoters[which(!Missing("State")),]
demVoters <- demVoters[which(!Missing("HomePhone")),]
demVoters <- demVoters[which(!Missing("Phone")),]
demVoters <- demVoters[which(!Missing("Age")),]
# The above didn't cause any drops
#######
# KEEP OBSERVATIONS WITH UNKNOWN SEX (DON'T RUN NEXT THREE LINES PER SAUL)
#######
# SEX - DROPPING UNKOWNS (this is what was done in the nh script)
#demVoters <- demVoters[which(demVoters$Sex != "U"),]
#demVoters$Sex <- factor(demVoters$Sex)
# But look at the strange gender distribution
table(factor(demVoters$Sex))
prop.table(table(factor(demVoters$Sex)))
barplot(table(factor(demVoters$Sex)), main = "Sex")
#########
# CREATE HOUSEHOLD ID
#########
uniqueAds <- unique(sort(demVoters$ad))
demVoters$adid <- NA
demVoters$adid <- match(demVoters$ad,uniqueAds)
#demVoters$adid <- as.numeric(as.factor(demVoters$ad)) #alternative
# Check to make sure that there there is only one adid for each add
length(unique(demVoters$adid)) == length(unique(demVoters$ad))
#########
# DROP ROWS FOR WHICH A PHONE NUMBER IS ASSOCIATED WITH MORE THAN ONE ADDRESS
#########
#create empty column for boolean bad phone or not
demVoters$badPhone <- NA
# establish progress bar for loop
pb <- txtProgressBar(min=1,max=nrow(demVoters),style=3) ####### Progress of loop
for (i in 1:nrow(demVoters)){
#isolate phone number
myPhone <- demVoters$Phone[i]
# number of addresses associated with that phone number
nAd <- length(unique(demVoters$adid[which(demVoters$Phone == myPhone)]))
# indicate whether it's anything besides 1
demVoters$badPhone[i] <- 1 != nAd
#update progress bar in loop
setTxtProgressBar(pb, i)
}
# How many of the 209,309 in our dataset have phones associated with more than one address?
table(demVoters$badPhone)
barplot(table(demVoters$badPhone), main = "Bad phone number")
#drop them
demVoters <- demVoters[which(!demVoters$badPhone),] # 48,260 dropped
#########
# # HOW MANY PEOPLE AT EACH ADDRESS ?
#########
demVoters$n <- NA
pb <- txtProgressBar(min=1,max=nrow(demVoters),style=3) ####### Progress of loop
for (i in 1:nrow(demVoters)){
demVoters$n[i] <-
nrow(demVoters[which(demVoters$adid == demVoters$adid[i]),])
setTxtProgressBar(pb, i)
}
# How many roommates do people have?
table(factor(demVoters$n - 1))
prop.table(table(factor(demVoters$n - 1)))
table(factor(demVoters$n <=5)) # 4094 have greater than 5 people in their house
par(mfrow=c(1,2))
barplot(table(factor(demVoters$n - 1)), main = "Cohabitation (how many roommates?)")
barplot(table(factor(demVoters$n >5)), main = "Greater than 5 people in house?")
par(mfrow=c(1,1))
#########
# EXCLUDE THOSE WITH HOUSEHOLD SIZE >=5 (doing this because in nh script it was done)
#########
demVoters <- demVoters[which(demVoters$n <=5),] #drops 4,094
#########
# HOUSEHOLD THE DATA BY RANDOMLY DRAWING A HOUSEHOLD REP IN HOUSEHOLDS
# WITH MORE THAN ONE INDIVIDUAL (OR BY DRAWING THE INDIVIDUAL WITH
# THE HIGHEST PHONE SCORE IN THE HOUSEHOLD, IF WE HAVE THAT INFO) - we don't!
# THE NEXT TWENTY LINES OR SO ARE FAST AND WORK WELL.  I WANTED TO FIND A MORE
# "READABLE" SOLUTION, BUT I ENDED UP STICKING WITH THIS ONE (OTHER OPTIONS SEEMED LESS UNDERSTANDABLE)
#########
#######
# RANDOMIZE ORDER OF ROWS
#######
set.seed(1)
# Write function for randomizing row order
RandomRows = function(df){
return(df[sample(nrow(df),nrow(df)),])
}
# Randomize row order
demVoters <- RandomRows(df = demVoters)
#########
# CREATE A DATAFRAME OF UNIQUE ADDRESSES TO HOUSEHOLD
#########
ad <- uniqueAds
df <- data.frame(ad)
#########
# LEFT JOIN demVoters INTO df (CREATES HOUSEHOLD-REPPED DATASET BY MATCHING FIRST OCCURRENCE ONLY)
#########
df <- join(x = df,
y = demVoters,
by = "ad",
type = "left",
match = "first")
# NOTE: the above is defacto random sampling of households, using
# home address as the household ID.  The randomization of all rows in
# demVoters is faster than actually using the sample() function.
# df = the household rep dataset (140,705)
# demVoters = the master dataset (156,955)
#########
# RELEVEL SEX IN DF SINCE THERE ARE NO U's
#########
df$Sex <- factor(df$Sex, levels = c("F", "M"))
#########
# RANDOMLY ASSIGN 70,000 *GENDERED* HOUSEHOLDS TO BE ROBOCALLED
# (note, this was originally 60,000, but as of 2014-09-14, Saul requested change to 70,000)
#########
# CREATE VARIABLE (phase1) (initially populate with all FALSES)
df$phase1 <- FALSE
# ASSIGN 70,000 to be robocalled (only sample from those with known gender)
#2 steps
#1. create vector of indices to be taken
phase1Sample <- sample(x = 1:nrow(df[which(df$Sex != "U"),]),
size = 70000,
replace = FALSE)
#2. assign indices
df$phase1[which(df$Sex != "U")][phase1Sample] <- TRUE
#########
# LOGISTIC REGRESSION TO ENSURE BALANCING
#########
# First, create dummies as to whether or not they voted in 2010 and 2012
df$dum10 <- VoteFun("General10", data = df)
df$dum12 <- VoteFun("General12", data = df)
# for our model, we'll just use age, sex and voting in 2010 / 2012
# we don't have race, voter propensity
# and we choose not to use zip...
# Run model
fit <- glm(phase1 ~ Age + Sex + dum10 + dum12,
data = df,
family = binomial("logit"))
# View results
summary(fit)
# ! note: the having voted in 2012 general election dummy variable right on edge of p < 0.1 cutoff
# View confidence intervals on "odds" of assignment to phase 1
ci <- exp(cbind(OR = coef(fit), confint(fit, level = 0.9)))
ci
bp <- barplot(ci[-1,1], border = FALSE, plot=TRUE, ylim=c(0,1.2))
abline(h=1, col = "red")
errbar(x=bp[,1],
y=ci[-1,1],
yplus=ci[-1,3],
yminus=ci[-1,2],
add=TRUE,
type="n")
#########
# SAVE IMAGE FOR FAST LOADING LATER
#########
#save.image("preroboscreen/temp3.RData")
# DOUBLE CHECK TO MAKE SURE PHASE 1 PEOPLE HAVE 60,000 UNIQUE
# ADDRESSES AND PHONE NUMBERS
length(df$ad[which(df$phase1)])
length(df$Phone[which(df$phase1)])
#########
# WRITE CSV OF THE 70,000 TO ROBOCALLED IN PHASE 1
#########
phase1 <- df[which(df$phase1),c("VANID", "State", "Phone")]
#write.csv(phase1, "preroboscreen/phase1.csv", row.names = FALSE)
#########
# END WRITING SINK
#########
txtStop()
# END HERE
# !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
# !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
# !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
# !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
# !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
# !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
#########
for (i in 1:nrow(demVoters[1:100,])){
#isolate phone number
myPhone <- demVoters$Phone[i]
# number of addresses associated with that phone number
nAd <- length(unique(demVoters$adid[which(demVoters$Phone == myPhone)]))
# indicate whether it's anything besides 1
demVoters$badPhone[i] <- 1 != nAd
#update progress bar in loop
#setTxtProgressBar(pb, i)
}
for (i in 1:nrow(demVoters[1:200,])){
#isolate phone number
myPhone <- demVoters$Phone[i]
# number of addresses associated with that phone number
nAd <- length(unique(demVoters$adid[which(demVoters$Phone == myPhone)]))
# indicate whether it's anything besides 1
demVoters$badPhone[i] <- 1 != nAd
#update progress bar in loop
#setTxtProgressBar(pb, i)
}
pb <- txtProgressBar(min=1,max=nrow(demVoters),style=3) ####### Progress of loop
for (i in 1:nrow(demVoters[1:200,])){
#isolate phone number
myPhone <- demVoters$Phone[i]
# number of addresses associated with that phone number
nAd <- length(unique(demVoters$adid[which(demVoters$Phone == myPhone)]))
# indicate whether it's anything besides 1
demVoters$badPhone[i] <- 1 != nAd
#update progress bar in loop
setTxtProgressBar(pb, i)
}
demVoters$badPhone <- NA
# establish progress bar for loop
system.time(
for (i in 1:10000000){
i^3
})
####################
# LOAD
####################
library(maptools)
library(rgdal)
library(RColorBrewer)
library(Hmisc)
####################
# SET WD TO THE GIS FOLDER
####################
setwd("C:/Users/BrewJR/Documents/uf/phc6194/lecture2")
World30 <- readOGR("MapProjection.mdb",layer = "World30_Shape_Index")
setwd("C:/Users/BrewJR/Documents/uf/phc6194/hw2/")
World30 <- readOGR("MapProjection.mdb",layer = "World30_Shape_Index")
####################
# LOAD
####################
library(maptools)
library(rgdal)
library(RColorBrewer)
library(Hmisc)
####################
# SET WD TO THE GIS FOLDER
####################
setwd("C:/Users/BrewJR/Documents/uf/phc6194/hw2/")
World30 <- readOGR("MapProjection.mdb",layer = "World30_Shape_Index")
setwd("C:/Users/BrewJR/Documents/uf/phc6194/lecture2")
World30 <- readOGR("MapProjection.mdb",layer = "World30_Shape_Index")
library(maptools)
library(rgdal)
library(RColorBrewer)
library(Hmisc)
####################
# SET WD TO THE GIS FOLDER
####################
setwd("C:/Users/BrewJR/Documents/uf/phc6194/hw2/")
World30 <- readOGR("MapProjection.mdb",layer = "World30_Shape_Index")
